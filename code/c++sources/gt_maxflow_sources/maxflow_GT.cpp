#include <cmath>
#include "maxflow_GT.h"
#include "types.h"

maxflow_GT::maxflow_GT(){
    info.name = " GT";
};

void maxflow_GT::construct(const dynamic::num_array<int, 2> &E, dynamic::num_array<int, 2> &cap, dynamic::num_array<int, 1> &excess)
{
    using namespace exttype;
    g.construct(excess.size(), E.size()[1], E.begin(), cap.begin(), excess.begin());
}

maxflow_GT::tflow maxflow_GT::maxflow()
{
    std::cout << "num nodes in maxflow_GT::maxflow() " << g.n << std::endl;
    std::cout << "num edges in maxflow_GT::maxflow() " << g.m << std::endl;
    info.solve_t.start();
    g.stageOne();
    info.flow = g.flow;
    g.globalUpdate(); // required to determine the minimum cut
    info.solve_t.stop();
    if(g.globUpdtFreq<0.001){
	info.name = "GT0";
    }else if(fabs(g.globUpdtFreq-0.5)<0.01){
	info.name = "GT05";
    }else{
	info.name = txt::String::Format("GT%2.1f",g.globUpdtFreq);
    };
    info.nV = g.n;
    info.nE = g.m;
    return info.flow;
}

void maxflow_GT::construct(const char *filename)
{
    dimacs_parser(filename, *this, 2);
}

void maxflow_GT::allocate1(int n, int m, int S, int T)
{
    g.n = n;
    g.nodes = (node*)calloc((n + 2), sizeof(node));
    g.source = g.nodes + S;
    g.sink = g.nodes + T;
    g.m = 0;
    g.flow0 = 0.;
    g.flow = 0.;
    g.nMin = 0;
}

void maxflow_GT::allocate2(int loop)
{
    if (loop == 0)
	{
	    g.arcs = (arc*)calloc((2 * g.m + 1), sizeof(arc));
	    g.cap = (float*)calloc((2 * g.m + 1), sizeof(float));
	    size_t		accum_size = 0;
	    for (node *v = g.nodes; v != g.nodes + g.n + 2; ++v)
		{
		    size_t	s = (size_t&)v->first;
		    v->first = g.arcs + accum_size;
		    v->current = v->first;
		    accum_size += s;
		}
	    assert(accum_size <= 2 * g.m + 1);
	    g.m = 0;
	}
    else
	{
	    g.allocDS();
	    g.init();
	}

}

void maxflow_GT::read_arc(int loop, int u, int v, float cap1, float cap2)
{
    if (loop == 0)
	{
	    ++g.m;
	    ++(size_t&)g.nodes[u].first;
	    ++(size_t&)g.nodes[v].first;
	}
    else
	{
	    arc *&uv = g.nodes[u].current;
	    arc *&vu = g.nodes[v].current;
      
	    uv->head = g.nodes + v;
	    vu->head = g.nodes + u;
	    uv->resCap = cap1;
	    g.cap[uv - g.arcs] = cap1;
	    vu->resCap = cap2;
	    g.cap[vu - g.arcs] = cap2;
	    uv->rev = vu;
	    vu->rev = uv;
	    ++uv;
	    ++vu;
	    ++g.m;
	}
}

void maxflow_GT::save_cut()
{
    float flow = 0.;
    int vertices = 0;
    std::cout << "cost = " << g.cut_cost() << std::endl;
  
    flow = g.flow;
    for (int v=0; v<g.n; ++v)
	{
	    if (g.is_weak_source(&g.nodes[v]) && (v != (g.source - g.nodes))) 
		// v attached to source and is not source
		{
		    vertices++;
		    std::cout << (v+1) << " ";
		}
	}
    std::cout << std::endl;
    std::cout << "flow = " << flow << std::endl;
    std::cout << vertices << " vertices attached to the source." << std::endl;
}

void maxflow_GT::save_nodes(int num_nodes)
{
    float flow = 0.;
    int vertices = 0;
	
    int v_multitask;
    int i_aux = -1;

    int num_tasks_printed = 0;

    flow = g.flow;
	
    for (int v = 0; v < g.n; v++)
	{
	    if (g.is_weak_source(&g.nodes[v]) && (v != (g.source - g.nodes)))
		{
		    // v attached to source and is not source
		    vertices++;
			
		    if (num_nodes <= 0)
			// ignore multi-task, print as before
			std::cout << (v+1) << " ";
			
		    else
			{
			    v_multitask = (v + 1);
				
			    for (int i = 0; v_multitask > num_nodes; i++)
				{
				    v_multitask -= num_nodes;
					
				    if (i > i_aux) // change task
					{					    
					    i_aux = i;
					    std::cout << std::endl;
					    num_tasks_printed++;
					}
				}
			    std::cout << v_multitask << " ";
			}
			
		}
	}
    // print line returns for all tasks with no selected nodes
    // that appear after the last task for which nodes were selected
    num_tasks_printed = (g.n/num_nodes) - 1 - num_tasks_printed; // number to print
    for (int i=0; i < num_tasks_printed; i++){
	std::cout << std::endl;
    }
    
    std::cout << std::endl; // final line return
}

void maxflow_GT::save_cut_to_file(const std::string & filename){
    FILE * f = fopen(filename.c_str(),"wt+");
    setvbuf(f,NULL,_IOFBF,1024*1024*2);
    fprintf(f,"p max %lli %lli\n",(long long)g.n, (long long)g.m);
    fprintf(f,"c minimum cut, generated by %s\n",info.name.c_str());
    fprintf(f,"f %f\n",info.flow);
    for(int v=0;v<g.n;++v){
	fprintf(f,"n %i %i\n",v+1,g.is_weak_source(&g.nodes[v]));
    };
};



void maxflow_GT::get_cut(int * C){
    for(int v=0;v<g.n;++v){
	C[v] = g.is_weak_source(&g.nodes[v]);
    };
};

double maxflow_GT::cut_cost(){
    return g.cut_cost();
};
